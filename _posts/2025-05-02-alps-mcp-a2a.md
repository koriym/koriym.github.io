---
layout: post
title: ALPSとMCPとA2A：REST制約が生み出すAIとの対話 (2)
date: 2025-05-03 00:00:00 +0900
comments: false
categories: ["blog"]
tags:
  - ALPS
  - MCP
  - A2A
  - REST
  - AI
image: /images/2025-04-22-alps-mcp/day0.png
permalink: /blog/2025/05/02/alps-mcp-a2a
list_title: false
---
## ALPS と最新 AI プロトコル標準（MCP と A2A）の自然なシナジー

### はじめに

人工知能（AI）が進化を続ける中で、標準化されたコミュニケーション基盤の重要性はますます高まっています。現在、AI インターフェースのための包括的なエコシステムを形づくる 3 つの主要プロトコルが登場しています。

* **ALPS（Application‑Level Profile Semantics）**
* **MCP（Model Context Protocol）**
* **A2A（Agent‑to‑Agent Protocol）**

本記事では、それぞれのプロトコルの特徴と相互補完的な関係性を概観し、より強力で相互運用可能な AI システムを実現するための自然なシナジーを探ります。

---

## 3 つのプロトコルを理解する

### ALPS ― セマンティックの基盤

ALPS は 2013 年に Mike Amundsen らが提唱した、REST API のセマンティクスを記述するためのプロファイル形式です。技術的な実装から独立して、リソースや操作の「意味」を明確に定義できます。

* **セマンティック・ディスクリプタ**: API 内の概念や操作を表現
* **メディアタイプ非依存**: 実装やデータ形式に縛られない
* **自己記述性**: セマンティックレベルで自己説明的
* **共通語彙の確立**: API 連携時の共通言語を提供

### MCP ― モデルをコンテキストへ接続

Anthropic が開発した MCP は、言語モデルが外部ツールやデータソースと標準的に連携できるようにするプロトコルです。最新情報の取得や専用ツールの利用を可能にし、モデルと外界を橋渡しします。

* **ツール呼び出し**: モデルによる外部ツール利用方法を定義
* **コンテキスト情報**: 外部データ組み込みの枠組みを提供
* **標準化インタラクション**: 一貫したモデル‑ツール連携パターン
* **安全な権限制御**: 安全なデータアクセス機構を含む

### A2A ― エージェント協調を実現

Google が 2025 年に提案した A2A は、自律 AI エージェント同士の通信を容易にします。異なるベンダーやフレームワークで構築されたエージェント同士でも、相互発見と協調が可能です。

* **エージェントカード**: エージェント能力を記述する標準 JSON
* **タスクモデル**: 作業単位の定義と追跡構造
* **通信パターン**: 同期・非同期を含む通信プロトコル
* **企業向けセキュリティ**: 高度な相互認証と権限制御

---

## シナジスティックな関係

### 1. 階層的な分担

| レイヤ       | 役割              | プロトコル    |
| --------- | --------------- | -------- |
| セマンティック   | ドメイン概念・操作の意味を定義 | **ALPS** |
| コンテキスト    | モデルがツールやデータを利用  | **MCP**  |
| コーディネーション | 専門エージェント同士を協調   | **A2A**  |

ALPS が共通語彙を、MCP が外部連携を、A2A がエージェント間調整を担い、三位一体で AI 連携全体をカバーします。

### 2. プロトコル間の情報フロー（ディナーパーティー例）

1. **ALPS** が「レシピ」「食材」「買い物リスト」などの意味を定義
2. **MCP** がレシピ DB 参照や買い物ツール利用をモデルに許可
3. **A2A** が「レシピ推薦エージェント」「買い物リスト生成エージェント」「食事プランニングエージェント」を連携

### 3. REST 原則の共通採用

* **リソース指向**
* **ハイパーメディア駆動**
* **自己記述性**
* **ステートレス**

同一のアーキテクチャ哲学を共有するため、統合が自然に行えます。

---

## 実装例：レシピプランニングシステム

### 1. ALPS プロファイル（一部）

```json
{
  "alps": {
    "version": "1.0",
    "descriptor": [
      {
        "id": "Recipe",
        "type": "semantic",
        "descriptor": [
          {"id": "name",          "type": "semantic"},
          {"id": "ingredients",   "type": "semantic"},
          {"id": "cookingTime",   "type": "semantic"}
        ]
      },
      {
        "id": "searchRecipes",
        "type": "safe",
        "rt":  "#Recipe",
        "descriptor": [
          {"id": "query",        "type": "semantic"},
          {"id": "cookingTime",  "type": "semantic"}
        ]
      },
      {
        "id": "createShoppingList",
        "type": "unsafe",
        "descriptor": [
          {"id": "recipeId", "type": "semantic"},
          {"id": "servings", "type": "semantic"}
        ]
      }
    ]
  }
}
```

### 2. MCP 連携（ツール定義例）

```json
{
  "mcp": {
    "tool_use": [
      {
        "name": "recipe_search",
        "description": "条件でレシピを検索",
        "params": {
          "query":       {"type": "string",  "description": "キーワード"},
          "cookingTime": {"type": "integer", "description": "最大調理時間(分)"}
        },
        "returns": "該当レシピのリスト"
      }
    ]
  }
}
```

### 3. A2A 例（エージェント定義）

```json
{
  "agent": {
    "name": "RecipeRecommendationAgent",
    "description": "好みに合ったレシピを提案",
    "capabilities": [
      {
        "id": "recommend_recipes",
        "description": "適切なレシピを選定",
        "inputs":  {"preferences": {"type": "object", "description": "ユーザ嗜好"}},
        "outputs": {"recipes":     {"type": "array",  "description": "推薦レシピ"}}
      }
    ]
  }
}
```

---

## 組み合わせによる利点

1. **セマンティック一貫性**
   ALPS が単一の語彙を提供するため、MCP・A2A 間で翻訳コストが発生しません。

2. **発見可能な知性**

    * 意味（ALPS）
    * 利用可能ツール（MCP）
    * エージェント能力（A2A）
      が自己記述的で、より自律的かつ適応的なシステムを実現します。

3. **柔軟なレイヤード設計**
   ALPS → MCP → A2A の順に段階導入が可能。ニーズに応じて拡張できます。

4. **将来性**
   新モデル・新ツール・新エージェントが登場しても、既存の ALPS 定義を踏襲しつつ簡単に参加できます。

---

## 実装戦略

1. **まずセマンティックモデリング**
   ドメイン概念を ALPS で定義し、共通理解の源泉に。

2. **プロトコルをレイヤーで追加**

    * 人間向け REST API（ALPS）
    * モデル連携（MCP）
    * エージェント協調（A2A）

3. **ALPS を単一の真実のソースに**
   MCP・A2A の実装でも ALPS 語彙を直接参照し、意味のずれを防ぎます。

4. **ハイパーメディア駆動を徹底**
   リンクやフォームなどのアフォーダンスを一貫して利用し、自己記述性を最大化します。

---

## 結論

ALPS が **セマンティックの明確化**、MCP が **コンテキストの活用**、A2A が **エージェント協調** を担うことで、相互運用性・発見性・適応性に優れた AI システム基盤が完成します。

今後、AI インターフェースは「どのプロトコルを選ぶか」ではなく、**それらをいかに巧みに重ね合わせ、セマンティクス豊かでコンテキスト認識型、協調的な知能システムを構築するか** が鍵となるでしょう。


## サンプル

思考時間: 6 秒


以下に **「レシピ・プランニング最小実装」** を想定し、
1️⃣ ALPS プロファイル、2️⃣ REST API 例、3️⃣ MCP ツール定義と呼び出し、4️⃣ A2A エージェント協調――の４段階で“動く”サンプルを示します。
（そのままコピーして動かせるよう **JSON/YAML/HTTP** だけで構成しています）

---

## 1️⃣ ALPS プロファイル（`alps/recipes.json`）

```json
{
  "alps": {
    "version": "1.0",
    "descriptor": [
      { "id": "Recipe",  "type": "semantic",
        "descriptor": [
          { "id": "name",         "type": "semantic" },
          { "id": "ingredients",  "type": "semantic" },
          { "id": "cookingTime",  "type": "semantic" }
        ]
      },

      { "id": "searchRecipes", "type": "safe", "rt": "#Recipe",
        "descriptor": [
          { "id": "query",        "type": "semantic" },
          { "id": "maxTime",      "type": "semantic" }
        ]
      },

      { "id": "createShoppingList", "type": "unsafe",
        "descriptor": [
          { "id": "recipeId", "type": "semantic" },
          { "id": "servings", "type": "semantic" }
        ]
      }
    ]
  }
}
```

---

## 2️⃣ REST API 呼び出し例（Hypermedia＋ALPS）

```
GET /recipes?query=pasta&maxTime=30
Accept: application/hal+json
```

```json
{
  "_links": {
    "self":         { "href": "/recipes?query=pasta&maxTime=30" },
    "alps":         { "href": "/alps/recipes.json" },
    "recipe": [
      { "href": "/recipes/42" },
      { "href": "/recipes/99" }
    ]
  },
  "count": 2,
  "_embedded": {
    "recipe": [
      {
        "id": 42,
        "name": "10‑Minute Garlic Pasta",
        "cookingTime": 10,
        "_links": {
          "self":              { "href": "/recipes/42" },
          "createShoppingList":{ "href": "/recipes/42/shopping-list", "method": "POST" }
        }
      }
    ]
  }
}
```

ALPS へのリンク (`"alps"`) により、クライアントも LLM も
**“searchRecipes はセーフ操作”** などの意味を機械的に取得できます。

---

## 3️⃣ MCP ツール定義（`mcp/recipe_tools.json`）

```json
{
  "tools": [
    {
      "name": "recipe_search",
      "description": "条件でレシピを検索（searchRecipes）",
      "endpoint": "/recipes",
      "method": "GET",
      "params": {
        "query":   { "type": "string",  "required": true },
        "maxTime": { "type": "integer", "required": false }
      },
      "returns": "#Recipe[]"
    },
    {
      "name": "create_shopping_list",
      "description": "レシピから買い物リストを生成（createShoppingList）",
      "endpoint": "/recipes/{recipeId}/shopping-list",
      "method": "POST",
      "params": {
        "recipeId": { "type": "integer", "required": true },
        "servings": { "type": "integer", "required": true }
      },
      "returns": "ShoppingList"
    }
  ]
}
```

### MCP 呼び出し例（LLM からの JSON メッセージ）

```jsonc
{
  "tool": "recipe_search",
  "arguments": { "query": "vegan curry", "maxTime": 25 }
}
```

> **LLM** は ALPS 語彙をそのまま使い「maxTime は cookingTime の絞り込みだ」と理解。

---

## 4️⃣ A2A エージェント協調

### 4‑1. エージェントカード ① RecipeRecommendationAgent

```json
{
  "version": "1.0",
  "agent": {
    "name": "RecipeRecommendationAgent",
    "description": "嗜好に基づきレシピ候補を返す",
    "capabilities": [
      {
        "id": "recommend",
        "input":  { "preferences": "object" },
        "output": { "recipes": "#Recipe[]" }
      }
    ],
    "dependencies": ["recipe_search"]
  }
}
```

### 4‑2. エージェントカード ② ShoppingListAgent

```json
{
  "version": "1.0",
  "agent": {
    "name": "ShoppingListAgent",
    "description": "選択レシピから買い物リストを生成",
    "capabilities": [
      {
        "id": "build_list",
        "input":  { "recipeId": "integer", "servings": "integer" },
        "output": { "shoppingList": "ShoppingList" }
      }
    ],
    "dependencies": ["create_shopping_list"]
  }
}
```

### 4‑3. A2A での協調フロー（YAML）

```yaml
# 1) 司令役 OrchestratorAgent がディナー条件を提示
- from: OrchestratorAgent
  to: RecipeRecommendationAgent
  action: recommend
  payload:
    preferences:
      diet: vegan
      maxTime: 25
      servings: 4

# 2) 推薦結果を受け取り、最初のレシピ ID=42 を選択
- from: RecipeRecommendationAgent
  to: OrchestratorAgent
  payload:
    recipes: [42, 99]

# 3) 買い物リスト生成を依頼
- from: OrchestratorAgent
  to: ShoppingListAgent
  action: build_list
  payload:
    recipeId: 42
    servings: 4

# 4) 完成したリストを返却
- from: ShoppingListAgent
  to: OrchestratorAgent
  payload:
    shoppingList: { /* ...items... */ }
```

ここで各エージェントは **ALPS 語彙**（`recipeId`, `servings` など）を共通で使用し、
ツール呼び出しは **MCP** に従って安全に実行されます。

---

### まとめ

1. **ALPS** が「意味」を宣言
2. **REST** API がハイパーメディアで自己記述
3. **MCP** が LLM⇒API の橋渡し
4. **A2A** が複数エージェントを編成

この 4 点セットを揃えるだけで、**人間・LLM・エージェントすべてが同じ語彙で協調**し、拡張も容易な AI サービス基盤を組めます。
