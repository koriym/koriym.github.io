# DX vs AX 具体例メモ

## 核心

AIにとってはフレームワークの人気やエコシステムの大きさは関係ない。
検証可能な制約が定義されているかどうか、それだけが問題。

## DX（人間の書きやすさ） vs AX（機械的な検証可能性）

| DX側 | AX側 | 理由 |
|------|------|------|
| ORM | SQL | EXPLAINで実行計画を検証可能 |
| 型なし連想配列 | DTO / psalm型付き配列 | 型が定義されているかどうかが本質。手段は問わない |
| YAML設定 | XML + XSD | XSDで構造を厳密に定義・検証可能。YAMLにスキーマ標準なし |
| カスタムAPI | REST（HATEOAS） | リンクでAIが次の操作を機械的に発見可能 |
| クエリビルダー | SQL | 生成SQLが見えにくい vs EXPLAINで検証可能 |
| マジックナンバー/文字列定数 | 型付きEnum | 取りうる値が型レベルで閉じている。網羅性を検証可能 |
| ダックタイピング | インターフェース | 契約が明示的に定義されているか、暗黙の振る舞いに依存か |
| 自由形式のAPIドキュメント | ALPS | セマンティクスが機械可読な形式で定義されているか |
| 「気をつけて書く」 | CSP等のポリシー | セキュリティ制約が機械的に検証可能か、人間の注意力依存か |
| 規約ベースのルーティング | 明示的なルート定義 | 人間が覚えやすい vs 機械が解析可能 |
| マジックメソッド(__get等) | 明示的なメソッド | 静的解析が効くかどうか |

## ソフトウェア原則とAX

| DX側（違反） | AX側（原則） | 理由 |
|------|------|------|
| publicフィールド直接操作 | OOP（カプセル化） | 公開メソッドが契約として機能し、不変条件を検証可能 |
| 具象依存 | DIP（依存性逆転） | インターフェースに依存することで差し替え・検証が容易 |
| サービスロケータ/グローバル | DI（コンストラクタインジェクション） | 依存が型として宣言され、コンパイル時に検証可能。ボイラープレートはAIには問題にならない |
| 神クラス | SRP（単一責任） | 責任が分離されていれば影響範囲を機械的に特定可能 |
| 継承の多用 | OCP + LSP | 拡張に開き置換可能であることが型レベルで保証される |

- SOLID等の原則は「人間のため」と思われがちだが、本質は制約の明示化
- 人間には守るのが難しかった原則を、AIは定義さえあれば愚直に従える
- つまりSOLIDは最初からAX的だった

## ポイント

- パターンは一貫：暗黙の規約・人間の注意力・ドキュメント依存 = DX / 明示的制約・機械的検証・スキーマ定義 = AX
- Doing vs Beingの具体例そのもの
- フレームワークの選択基準自体が変わりうる
- 「人間には難しすぎて守れなかったソフトウェア原則を、AIは愚直に守る」
- psalm/phpstanのレベルマックス：人間はDXの理由で下げていた。AIなら最初からmax。制約が厳しいほど検証可能性が上がる
- ステートレス：状態がなければ入出力だけで検証可能。副作用の追跡不要
- イミュータブル：値が変わらないので、どの時点でも同じ結果が保証。AIが推論しやすい
- サイクロマティック複雑度を低く：分岐が少ないほどテストの網羅性を機械的に保証できる
- JSON Schema vs フレームワーク独自ルール：標準仕様はAIの外部に存在する検証可能な制約。独自ルールはフレームワーク内部知識に依存
- 共通パターン：人間がDXのために緩めてきた制約を、AIの時代には戻せる
